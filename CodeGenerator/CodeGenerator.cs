using EntityGenerator.EntityGenerator.Wpf;
using System;
using System.Collections.Generic;
using System.Text;

namespace EntityGenerator.Wpf
{
    public static class CodeGenerator
    {
        // Map SQL type to C# type
        private static string GetCSharpType(string sqlType, bool isNullable)
        {
            string type = sqlType.ToLower() switch
            {
                "int" => "Int32",
                "bigint" => "Int64",
                "smallint" => "Int16",
                "tinyint" => "Byte",
                "bit" => "bool",
                "decimal" or "numeric" or "money" or "smallmoney" => "decimal",
                "float" => "double",
                "real" => "float",
                "datetime" or "datetime2" or "smalldatetime" or "date" or "time" => "DateTime",
                "uniqueidentifier" => "Guid",
                _ => "string"
            };

            if ((type != "string" && type != "byte[]") && isNullable)
            {
                type += "?";
            }

            return type;
        }

        private static string ToPropertyName(string columnName) => columnName;

        // ------------- BASE CLASS ----------------

        public static string GenerateBaseClass(string namespaceName, string tableName, List<ColumnInfo> columns)
        {
            var className = tableName + "Base";
            var sb = new StringBuilder();

            // Build dynamic usings for BASE class
            var usings = new HashSet<string>
            {
                "using System;"
            };
            // (Right now base class only needs System; add more if you start using other types)

            sb.AppendLine("/*");
            sb.AppendLine("File generated by custom templates");
            sb.AppendLine("Important: Do not modify this file. Edit the file " + tableName + ".cs instead.");
            sb.AppendLine("*/");

            sb.AppendLine("#region using directives");
            foreach (var u in usings)
                sb.AppendLine(u);
            sb.AppendLine("#endregion");
            sb.AppendLine();

            sb.AppendLine("namespace " + namespaceName);
            sb.AppendLine("{");
            sb.AppendLine("    [Serializable]");
            sb.AppendLine("    public abstract class " + className + ": BaseEntity");
            sb.AppendLine("    {");
            sb.AppendLine("        #region Constructors");
            sb.AppendLine("        protected " + className + "()");
            sb.AppendLine("        {");

            // IsActive default = true
            var hasIsActive = columns.Exists(c =>
                string.Equals(c.ColumnName, "IsActive", StringComparison.OrdinalIgnoreCase) &&
                string.Equals(c.SqlType, "bit", StringComparison.OrdinalIgnoreCase));

            if (hasIsActive)
            {
                sb.AppendLine("            this.IsActive = true;");
            }

            sb.AppendLine("        }");
            sb.AppendLine("        #endregion");
            sb.AppendLine("        #region Properties");

            foreach (var col in columns)
            {
                var propName = ToPropertyName(col.ColumnName);
                var csharpType = GetCSharpType(col.SqlType, col.IsNullable);
                var fieldName = "_" + char.ToLowerInvariant(propName[0]) + propName[1..];

                sb.AppendLine();
                sb.AppendLine("        private " + csharpType + " " + fieldName + ";");
                sb.AppendLine("        public virtual " + csharpType + " " + propName);
                sb.AppendLine("        {");
                sb.AppendLine("           get");
                sb.AppendLine("           {");
                sb.AppendLine("               return " + fieldName + ";");
                sb.AppendLine("           }");
                sb.AppendLine("           set");
                sb.AppendLine("           {");
                sb.AppendLine("               if (" + fieldName + " == value) return;");
                sb.AppendLine("               " + fieldName + " = value;");
                sb.AppendLine("               EntityModified();");
                sb.AppendLine("           }");
                sb.AppendLine("        }");
            }

            sb.AppendLine();
            sb.AppendLine("        #endregion");
            sb.AppendLine("        public void AddValidationRules()");
            sb.AppendLine("        {");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        // ------------- DERIVED CLASS ----------------

        public static string GenerateDerivedClass(string namespaceName, string tableName, List<ColumnInfo> columns)
        {
            var className = tableName;
            var sb = new StringBuilder();

            // First pass: decide which usings we actually need
            var usings = new HashSet<string>
            {
                "using System;"
            };

            bool needsDataAnnotations = false;

            foreach (var col in columns)
            {
                var propName = ToPropertyName(col.ColumnName);

                bool isPk = col.IsPrimaryKey;
                bool isString =
                    string.Equals(col.SqlType, "nvarchar", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(col.SqlType, "varchar", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(col.SqlType, "nchar", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(col.SqlType, "char", StringComparison.OrdinalIgnoreCase);

                bool isNotNullable = !col.IsNullable;
                bool isIsActive =
                    string.Equals(propName, "IsActive", StringComparison.OrdinalIgnoreCase) &&
                    string.Equals(col.SqlType, "bit", StringComparison.OrdinalIgnoreCase);

                bool specialLoginOrPassword =
                    string.Equals(propName, "LoginName", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(propName, "Password", StringComparison.OrdinalIgnoreCase);

                // If any column will get attributes, we need DataAnnotations
                if (isPk || (isString && isNotNullable) || isIsActive || specialLoginOrPassword)
                {
                    needsDataAnnotations = true;
                }
            }

            if (needsDataAnnotations)
            {
                usings.Add("using System.ComponentModel.DataAnnotations;");
            }

            sb.AppendLine("/*");
            sb.AppendLine("File generated by custom templates");
            sb.AppendLine("*/");

            sb.AppendLine("#region using directives");
            foreach (var u in usings)
                sb.AppendLine(u);
            sb.AppendLine("#endregion");
            sb.AppendLine();

            sb.AppendLine("namespace " + namespaceName);
            sb.AppendLine("{");
            sb.AppendLine("    [Serializable]");
            sb.AppendLine("    public class " + className + ": " + className + "Base");
            sb.AppendLine("    {");
            sb.AppendLine("        #region Constructors");
            sb.AppendLine("        public " + className + "():base(){}");
            sb.AppendLine("        #endregion");

            // Second pass: actually generate properties with attributes
            foreach (var col in columns)
            {
                var propName = ToPropertyName(col.ColumnName);

                bool isPk = col.IsPrimaryKey;
                bool isString =
                    string.Equals(col.SqlType, "nvarchar", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(col.SqlType, "varchar", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(col.SqlType, "nchar", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(col.SqlType, "char", StringComparison.OrdinalIgnoreCase);

                bool isNotNullable = !col.IsNullable;
                bool isIsActive =
                    string.Equals(propName, "IsActive", StringComparison.OrdinalIgnoreCase) &&
                    string.Equals(col.SqlType, "bit", StringComparison.OrdinalIgnoreCase);

                bool specialLoginOrPassword =
                    string.Equals(propName, "LoginName", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(propName, "Password", StringComparison.OrdinalIgnoreCase);

                var attrSb = new StringBuilder();

                if (isPk)
                {
                    attrSb.AppendLine("        [Key]");
                }

                // Required for PKs and other non-nullable strings
                if (isPk || (isString && isNotNullable))
                {
                    attrSb.AppendLine("        [Required]");
                }

                //if (isIsActive)
                //{
                //    attrSb.AppendLine("        [Display(Name = \"Is Active\")]");
                //}

                // Admin-style resource-based attributes for LoginName / Password
                if (specialLoginOrPassword)
                {
                    attrSb.AppendLine("        [Required(ErrorMessageResourceType = typeof(Resources.Resources),");
                    attrSb.AppendLine("            ErrorMessageResourceName = \"RequiredFieldErrorMessage\")]");
                    attrSb.AppendLine("        [Display(Name = \"" + propName + "\", ResourceType = typeof(Resources.Resources))]");
                }

                if (attrSb.Length > 0)
                {
                    sb.Append(attrSb.ToString());
                    sb.AppendLine("        public override " + GetCSharpType(col.SqlType, col.IsNullable) + " " + propName);
                    sb.AppendLine("        {");
                    sb.AppendLine("            get { return base." + propName + "; }");
                    sb.AppendLine("            set { base." + propName + " = value; }");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }
    }
}
